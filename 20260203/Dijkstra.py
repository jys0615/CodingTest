### 간선은 인접 배열 혹은 리스트로 하는데 다익스트라는 리스트 ###
### 시작점에서 모든 노드까지 거리를 갱신할 배열이 필요. 초기는 무한대 ###
### 최대/최소 빠르게 찾는 힙을 사용한다. 거리 갱신 및 힙 추가 ###

### 코드 해석 ###
## 거리 배열을 초기값 갱신, 힙에 초기값 0,K를 넣는다
## 힙이 다 떠날 때까지 반복
## w는 현재 비용, v는 현재 노드
## 거리 배열에서 관리하고 있는 최신값과 일치 여부를 파악한다
## for 루프를 거치면서 갱신하는 과정을 거친다
## 최솟값인 것만 경신을 한다. 

### 백준 1753 - 최단경로 ###
### 간선 인접 리스트를 저장하고, 거리를 무한대로 초기화. 힙을 뻬면서 처리 ### 
### 아이디어 ###
## 다익스트라 - 한 점에서 다른 모든 점으로의 최단 경로 설정
## 모든 거리 무한대로 초기값
## 시작점 거리 0 설정 및 힙에 추가
## 힙에서 하나씩 빼면서 수행한다. 

### 시간복잡도: 힙의 삽입과 삭제는 lgN만큼의 시간복잡도가 필요
### 힙을 통한 처리 과정이 ElgE
### ElgV^2 => 빅오는 ElgV
### E는 30만, lgV는 20
### 10^6은 2^20과 유사
### lg = log2^20 = 20
### int가 사용가는한지 확인
### 거리배열 int[]
##### 코드 #####
'''
- 한 점 시작해서 모든 거리 구현은 다익스트라
- 간선을 인접 리스트에 저장, 거리 배열 무한대 초기화
- 시작점 : 거리배열 0, 힙에 넣어주기
- 힙에서 빼면서 다음의 것들 수행
    최신값인지 먼저 확인
    간선을 타고 간 비용이 더 작으면 갱신을 해준다

2. 시간복잡도
- 다익스트라 : O(lgV)
    - E : 3e5
    - V : 2e4, lgV ~= 20
    - ElgV = 6e6 > 가능
3. 변수
- 힙:(비용, 노드번호)
- 거리배열: 비용 : int[]
- 간선 저장, 인접리스트 : (비용, 노드번호)[]
'''

import sys
import heapq
input = sys.stdin.readline
INF = sys.maxsize
V, E = map(int, input().split())
K = int(input())
edge = [[] for _ in range(V+1)]
dist = [INF] * (V+1)
for i in range(E):
    u,v,w = map(int, input().split())
    edge[u].append([w,v])

# 시작점 초기화
dist[K] = 0
heap = [[0,K]]

while heap:
    ew, ev = heapq.heappop(heap)
    if dist[ev] != ew: 
        continue
    for nw, nv in edge[ev]:
        if dist[nv] > ew + nw:
            dist[nv] = ew+nw
            heapq.heappush(heap, [dist[nv], nv])

for i in range(1, V+1):
    if dist[i] == INF: print("INF")
    else: print(dist[i])

### 그냥 외워라 ###
## 연습 많이 해라 ##
## 다익스트라인지 알아내는 것이 중요하다
## 한 점에서 다른 점으로 가는 최소비용인지 알아내라 ##